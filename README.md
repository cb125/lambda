# lambda
*Programming language theory for linguists and philosophers of language*

This project brings together some of the concepts from the theory of programming languages that (in our idiosyncratic judgment) are the most useful or the most inspiring for semanticists and philosophers of natural language.  But practical tools are not the point here.  Rather, the emphasis is on intellectual joy.  That said, if you have any interest in the formal aspects of the meaning of natural or programming languages, then if we come anywhere close to succeeding, then this respository will contain all kinds of things that you will want to know.

This project is based on a course developed by the authors.  We taught it as a graduate seminar listed in both philosophy and linguistics at NYU, and once as a one-week course at NASSLLI. There were many amazing people who joined us in those courses, and we remain grateful to them all.

We prefer the interactive nature of a seminar for this material, and we have made an effort to make the materials here as interactive as possible.  Certainly it is not possible to fully internalize the concepts and techniques discussed here without engaging with the activities and exercises.  

If you work through these ideas, what will you know about?  The material falls into two main components: terms and their types.  The paradigm term language is the lambda calculus.  We'll build up from the basics to combinatory logic, evaluation order, Church numerals, and recursion.  On the types side, we'll cover simple types, System F, and functors, including especially monads and continuations.   

The goal of this book is to introduce concepts and
techniques from theoretical computer science and show how they can
provide insight into established philosophical and linguistic
problems.

This is not a book about any particular technology or
software. Rather, it's about a variety of conceptual/logical ideas
that have been developed in computer science and that linguists and
philosophers ought to know, or may already be unknowingly trying to
reinvent.

Philosophers and linguists tend to reuse the same familiar tools in
ever more (sometime spectacularly) creative ways. But when your only
hammer is classical logic, every problem looks like modus ponens. In
contrast, computer scientists have invested considerable ingenuity in
studying the design of their conceptual tools (among other things),
and they've made much progress that we can benefit from.

The theoretical tools we'll be introducing aren't part of the diet of
most everyday programmers, but they are prominent in academic computer
science, especially in the fields of functional programming and type
theory.

The course will not presume previous experience with programming. We
will, however, discuss concepts embodied in specific programming
languages, and we will encourage experimentation with running,
modifying, and writing computer programs.


## Topics

[Introduction to the lambda calculus](Content/lambda.md)

